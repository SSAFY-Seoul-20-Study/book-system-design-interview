# 처리율 제한 장치
> 클라이언트 / 서비스가 보내는 트래픽의 처리율을 제어하기 위한 장치. HTTP의 경우 클라이언트의 요청 횟수를 제한 하는 등의 방법을 쓴다. 정해 놓은 임계치를 넘어서면 그 뒤의 요청들은 중단(block)된다. 

### 이게 왜 필요할까요?
- 못된 사람들이 DDos 공격 등을 통해 우리 서버를 터뜨릴 수가 있답니다.


# Dos 공격
> Denail of Service

### 뜻
- **어떤 방식**이든 **의도적**으로 시스템 자원을 고갈 / 바쁘게 만들어서 서비스를 못쓰게 만드는 공격이다.

### 특징
- **해킹**과는 다르다! Dos 공격은 시스템 내부 정보에는 관심 없다. 아무튼 시스템만 다운시키면 됨
	- postman으로 서비스에 요청 오백만개 보내면, 얻는 정보는 한푼 없어도 서비스를 다운 시킬 수 있다. -> Dos 공격 성공~

- 종류가 무진장 많고 가장 친숙한 예가 DDos 공격
	


# DDos 공격
> Distributed Dos attack

## 뜻
- 대충 요청을 겁나게 보내서 서버를 다운 시키는 방법
- 단순하게 페이지 새로고침만 광클하는 것도 DDos에 해당할 수 있으시겠다.



# 처리율 한도 초과


## 3단계 - 상세설계

#### 응답 방식
- 처리율 규칙은 별도 설정 파일(configuration file)로 디스크에 저장한다
- 처리율 제한에 대한 결과는 HTTP 헤더를 통해 클라이언트에 제공 된다.

```
1. X-Ratelimit-Remaining
	윈도 내 남은 처리 가능 요청 수
2. X-Ratelimit-Limit
	매 윈도마다 클라이언트가 전송할 수 있는 요청 수
3. X-Ratelimit-Retry-After
	한도를 피하려면, 몇 초 뒤에 요청을 다시 보내야 하는지에 대한 정보
```
- 처리율 규칙에 걸리면 HTTP 429(Too many requests) 응답과 함께 해당 정보들을 알릴 수 있다.

#### 전체적인 설계
- **처리율 규칙 원본**: 디스크에 저장한다
- **캐시된 처리율 규칙**: 작업 서비스는 수시로 디스크에 저장된 규칙을 뽑아와 캐시한다
- **처리율 제한 미들웨어**: 캐시 공간에서 처리율 규칙을, 레디스에서 카운터와 타임스탬프를 가져온다. 
	- 규칙에 따라 429응답 / API 서버 응답을 클라이언트에 반환한다


#### 문제점
- Race condition 문제
	- 만약 두 쓰레드가 병렬로 counter 값을 읽어버리면, counter+2 대신 counter+1 값만 Redis에 저장될 것이다.
	- Lock으로 해결하기엔 너무 느리다
	- **해결**: 루아 스크립트  / Redis의 정렬집합을 통해 해결한다


- 동기화 문제  ????
	- 처리율 제한 서버가 여러 개인 경우, 앞선 요청과 이번 요청을 서로 다른 서버가 담당 할 수 있다.
	- 이 경우 statless 한 web 서버의 특성 상, 동기화 문제가 발생한다???
	- **해결** : Redis에 상태를 저장한다???
	- **애초에 처리율 제한 서버에 동기화 문제가 왜 발생하나요? -> 처리율 제한 서버에 특정 사용자에 관한 상태를 보관해야 하는 상황이 있나요?**
	- 
- 지역성 문제??
	- 서버랑 유저랑 거리가 멀면 latency가 증가한다
	- 때문에 지역 곳곳에 데이터센터를 주고 가까운 대로 라우팅 해준다.
	- **도대체 이게 처리율 제한이랑 무슨 상관 인가요?**


- 모니터링
	- 채택된 알고리즘 / 제한 규칙이 효과적인지는 모니터링하면서 잘 확인하자. (너무 많이 버려지진 않는지 등)
	- 깜짝 세일과 같은 특정 시점엔 그에 맞게 규칙을 변경하자
		- *토큰 버킷이 적절하단다*


## 4단계 - 추가학습

#### 경성 / 연성 처리율 제한
- 경성 -> 딱딱하다 -> 에누리 없이 요청 개수는 임계치를 넘을 수 없다
- 연성 -> 유연하다 -> 쬐끔은 봐준다

#### 다양한 계층에서의 처리율 제한
- Http(7계층) 에서 뿐 아니라 IP 주소(3계층) 등을 기반으로 처리율 제한을 걸 수가 있다.

#### 어떻게 처리율 제한을 회피할까?
- 사실 애초에 요청 자체를 줄일 수 있다면, 그게 최고다. -> 요청 버려지면 UX 박살남
	- **캐시**를 사용해 불필요한 요청 반복을 줄인다.
	- 애초에 임계치를 이해하고 짧은 시간에 너무 많이 보내지 않는다.
		- 외부 API의 경우, 처리율 규칙에 따라 요청 수 를 조절하는 방식
	- 예외 처리를 통해, 단순히 에러 상황을 보여주는게 아니라. 좀더 **우아하게** 복구하는 방식을 채택한다.
		- back-off 동안 로딩화면을 보여준다거나...게임이라도 시킨다거나...?
	- 재시도 로직을 구현할 땐, 충분하게 back-off를 둔다 (냅다 반복문으로 될때까지 보내지 말자구)