우리에게 가장 익숙한 유일 ID는 `auto_increment` 속성이 설정된 데이터베이스 칼럼일 것이다. 하지만, 이는 분산 환경에서는 유효하지 않다. 
- 데이터베이스 서버 한 대로 감당 불가 
- 여러 데이터베이스를 쓰게 되면 지연 시간을 낮추기가 무척 힘들어 짐 

### 유일 ID 요구 사항
- ID는 유일해야 한다. 
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급 날짜에 따라 정렬 가능해야 한다.
- 초당 10,000개의 ID를 만들 수 있어야 한다. 

# 방법 1️⃣ 다중 마스터 복제 
<img src="https://velog.velcdn.com/images/dbwogml15/post/80fd1729-880c-48be-bb7d-70fd286bf557/image.png" width=700>
- `auto_increment` 기능을 활용
- 다음 ID의 값을 구할 때 +1이 아닌, `+k`
	- k : 현재 사용 중인 데이터베이스 서버의 수 
- 데이터베이스 수를 늘리면 초당 생산 가능 ID 수도 늘릴 수 있음 

#### 단점
- 여러 데이터 센터에 걸쳐 규모를 늘리기 어려움 
- ID의 값이 시간 흐름에 맞추어 커지도록 보장할 수 없음 
- 서버를 추가하거나 삭제하는 경우 문제없이 동작하는게 어려움 

# 방법 2️⃣ UUID
> Universally Unique Identifier , 범용 고유 식별자 

: 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수 

[UUID(Universally Unique IDentifier)란?](https://mattmk.tistory.com/31)
- 네트워크 상에서 고유성이 보장되는 id를 만들기 위한 표준 규약
- 128비트의 숫자, 32자리의 16진수로 표현 
- 하이픈을 통해 5개의 그룹으로 구분 (8자리-4자리-4자리-4자리-12자리)
<img src="https://velog.velcdn.com/images/jupiter-j/post/6b61d5e4-3033-4547-935a-2a02d475a219/image.png" width="500">
**버전**
- 1,3,4,5의 버전이 존재
	- version1 : datetime + MAC address
	- version2 : datetime + MAC address + DCE
	- version3 : namespace + MD5
	- version4 : random
	- version5 : namespace + SHA1 hash
- 1버전과 4버전이 가장 많이 사용됨 

**자바에서 사용하기**
- `util` 패키지의 `UUID`
```java
import java.util.UUID;

public class UUIDTest {

    public static void main(String[] args) {
    
        UUID one = UUID.randomUUID();
        UUID two = UUID.randomUUID();
        System.out.println("UUID One: " + one.toString());
        System.out.println("UUID Two: " + two.toString());
    }
}
```

<img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F99F0E44F5B06C8760D" width="500">

[출처](https://wakestand.tistory.com/527)
#### 장점
- 단순한 생성
- 서버 간 독립적으로 생성 가능하여 동기화 이슈가 없음
- 규모 확장이 쉬움

#### 단점
- 생성되는 ID가 김(128비트)
- 시간순으로 정렬할 수 없음 
- ID에 숫자가 아닌 값이 포함됨

**참고 사항**
- datetime 정보가 포함되는 version1과 version2는 MAC 주소가 포함되어 있어, 보안상의 이유로 잘 사용되지 않는다.
- 따라서, `UUID` 는 타임스탬프 등의 정보 없이 무작위의 값이라고 이해하는 것이 좋다.
- 이를 보안하고자 `ULID` 가 만들어졌다. 

[UUID vs ULID](https://velog.io/@injoon2019/UUID-vs-ULID)

# 방법 3️⃣ 티켓 서버
> `auto_increment` 기능을 갖춘 데이터베이스 서버 

<img src="https://daeakin.github.io//images/large-system/ticket-server.png" width="600">
티켓 서버를 중앙 집중형으로 하나만 사용

[Ticket Servers: Distributed Unique Primary Keys on the Cheap](https://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)
- 다른 데이터 없이 ID만 보관하는 데이터베이스 
- `REPLACE INTO` 연산으로 원자성을 보장 
	- 기존에 있는 ID가 `INSERT` 된다면, 이전 행이 삭제됨 
```sql
CREATE TABLE `Tickets64`{
	`id` bigint(20) unsigned NOT NULL auto_increment,
	`stub` char(1) NOT NULL default '',
	PRIMARY KEY (`id`),
	UNIQUE KEY `stub` (`stub`)
} ENGINE=InnoDB
```

#### 장점
- 유일성이 보장되면서 숫자로만 구성되는 ID 생성 가능
- 구현하기 쉬움
- 중소 규모 애플리케이션에 적합

#### 단점
- 티켓 서버가 SPOF
	- 이를 방지하기 위해, 티켓 서버를 여러 대를 두면 동기화 문제가 발생 
	- `Flickr` 도 고가용성을 위해 티켓 서버를 2개 운영 

# 방법 4️⃣ 트위터 스노플레이크 접근법 

#### 각개 격파 전략 
<img src="https://velog.velcdn.com/images/mmy789/post/b282b7fd-7c03-4d14-9e2d-c7b0eacbfc5b/image.png" width="600">

`사인 비트`
- 1비트 할당
- 음수와 양수를 구별하는 데 사용

`타임스탬프`
- 41비트 할당
- 기원 시각 이후로 몇 밀리초가 경과했는지를 나타내는 값

`데이터센터 ID`
- 5비트 할당
- 총 2^5=32 개의 데이터센터 지원 가능 

**참고 사항**
> Q. 더 많은 데이터 센터를 지원해야 한다면?
> A.
> 1. 더 많은 비트 할당 : 데이터센터 ID와 서버 ID에 더 많은 비트를 할당하여 더 많은 수의 데이터센터를 지원할 수 있습니다. 예를 들어, 데이터센터 ID에 6비트를 할당하면 64개의 데이터센터를 지원할 수 있습니다. 이렇게 하면 더 많은 데이터센터를 식별할 수 있지만, ID의 길이가 더 길어질 수 있습니다.
> 2. 다른 식별 방법 사용 : 스노플레이크 접근법은 데이터센터 ID와 서버 ID를 사용하여 고유한 ID를 생성합니다. 하지만 데이터센터를 구분하는데 다른 방법을 사용할 수도 있습니다. 예를 들어, 데이터 센터의 물리적인 위치, IP 주소 범위 또는 도메인 이름 등을 사용하여 데이터센터를 식별할 수 있습니다.
> 3. 다른 아키텍처 선택 : 스노플레이크 접근법 외에도 다른 아키텍처를 고려할 수 있습니다. 예를 들어, 데이터센터 ID와 서버 ID 대신 다른 방식으로 고유한 ID를 생성하는 방법을 사용할 수 있습니다. 

`서버 ID`
- 5비트 할당 
- 데이터센터 당 2^5=32개의 서버 사용 가능

`일련번호`
- 12비트 할당 
- 각 서버에서 ID를 생성할 때마다 일련 번호를 1만큼 증가
- 1밀리초가 경과할 때마다 0으로 초기화

#### 작동 방식 
> 스노플레이크 접근법은 고유한 식별자(ID)를 생성하기 위한 분산 시스템에서 사용되는 방법입니다. 이 방법은 데이터센터와 서버를 구분하여 각각에 고유한 식별자를 부여하여 최종적으로 고유한 ID를 생성합니다.
> 스노플레이크 접근법에서는 데이터센터 ID와 서버 ID를 사용하여 ID를 생성하는데, 일반적으로 데이터센터 ID에는 5비트를 할당하고 서버 ID에도 5비트를 할당합니다. 이렇게 하면 데이터센터는 32개를 지원할 수 있고, 각 데이터센터 내에서는 32개의 서버를 지원할 수 있습니다.
> 이 방법은 분산 시스템에서 고유한 ID를 필요로 할 때 사용됩니다. 예를 들어, 대규모 서비스에서 수많은 서버가 데이터를 처리하고 저장하는 경우, 각 서버에 고유한 ID를 부여하여 데이터의 일관성과 식별성을 유지할 수 있습니다.
> 스노플레이크 접근법은 간단하면서도 효율적인 방법으로 분산 시스템에서 고유한 ID를 생성하는데 사용됩니다. 


- 데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정 
	- 잘못 변경되는 경우 ID 충돌 발생 가능 
- 타임스탬프를 통해 ID의 시간 순 정렬 가능 
	- 41비트의 타임스탬프로 2^(41)-1 밀리초 = 약 69년동안 정상 동작
	- 69년이 지나면 오버플로 발생을 방지하기 위해 기원 시각을 바꾸거나 ID 체계를 이전해야 함 
- 일련번호는 2개 이상이 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어낸 경우에만 0보다 큰 값을 가짐 

# 추가적인  고려 사항
- `시계 동기화` : 하나의 서버가 여러 코어에서 실행될 경우 유효하지 않을 수 있음 
	- NTP (Network Time Protocol)
	  > NTP(Network Time Protocol)는 컴퓨터 네트워크에서 시간 동기화를 위해 사용되는 프로토콜입니다. NTP는 인터넷을 통해 정확한 시간 정보를 제공하고 시스템들 간의 시간 동기화를 유지하는 역할을 합니다. 
	  > NTP는 클라이언트-서버 모델을 기반으로 동작합니다. 네트워크 상에 NTP 서버가 있고, 클라이언트는 이 서버에 접속하여 정확한 시간 정보를 요청합니다. NTP 서버는 다양한 시간원들과 연결되어 있으며, 이들의 시간 정보를 수집하고 정확한 시간을 계산하여 클라이언트에게 제공합니다.
	  > NTP는 시간 정보를 전달하는 데에 있어서 정밀도와 신뢰성을 중요하게 여깁니다. 따라서 NTP는 여러 가지 기술적인 방법을 사용하여 정확한 시간을 유지합니다. 이를 위해 NTP는 시간 서버들 간의 계층적인 구조를 형성하여 서로 시간 정보를 교환하고 정확성을 검증합니다.
	  > NTP는 다양한 응용 분야에서 사용되는데, 예를 들면 금융 거래, 네트워크 로깅, 시스템 로그 동기화 등에서 정확한 시간 동기화가 필요합니다. NTP를 사용하면 네트워크 상의 다양한 시스템들이 동일한 시간을 가지고 작업하므로 데이터의 일관성과 정확성을 유지할 수 있습니다.
	  > 요약하자면, NTP는 컴퓨터 네트워크에서 시간 동기화를 위해 사용되는 프로토콜로, 클라이언트-서버 모델을 기반으로 정확한 시간 정보를 제공하고 시스템들 간의 시간 동기화를 유지합니다. 
- `각 절의 길이 최적화`: 동시성, 수명 등의 애플리케이션 특징에 따라 절의 크기를 다르게 하는 것이 좋음 
	- 동시성이 낮고 수명이 길다면 타임스탬프 절을 늘리고 일련번호 절을 줄이는 것이 효과적 
- `고가용성`: ID생성기는 필수 불가결 컴포넌트 이므로 높은 가용성이 필요 