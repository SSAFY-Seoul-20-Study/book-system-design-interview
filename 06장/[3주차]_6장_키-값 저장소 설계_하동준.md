# 들어가며..

- 키는 일반 텍스트일 수도 있고 해시 값일 수도 있다.
- 성능의 이유로 짧을수록 좋다.
        
- 값은 문자열, 리스트, 객체 아무거나~

# 설계를 위해 고려해야하는 것들

- 큰 데이터 저장
- 높은 가용성
- 높은 규모 확장성
- 데이터 일관성 수준은 조정이 가능
- 응답 지연시간 짧아야

# 단일 서버 키-값 저장소

- 메모리 상에 모든 데이터를 올려 → 빠르지만 모든 데이터의 적재가 불가능할수도
    - 데이터 압축
    - 자주 쓰이는 데이터만 메모리에 두고 나머지는 디스크에 저장

# 분산 키-값 저장소

- 다른 말로 분산 해시 테이블이라고 한다.
- 이를 설계 시에는 CAP 정리를 이해해야함

# CAP 정리

- Consistency(데이터일관성=노드관계없이항상같은데이터), Availability(가용성=일부노드장애에도정상응답), Partition_Tolerance(파티션 감내=노드간통신장애에도정상동작)
- 셋을 모두 만족하는것은 불가능, 즉 용도에 따라 하나를 포기해야함
- 네트워크 장애는 없을수 없다. 따라서 P를 감내할 수 있도록 설계되어야한다. 따라서 CA시스템은 존재하지 않는다.

## CAP 정리 - 가정을 해보자.

세개의 노드 n1, n2, n3에 데이터를 복제하여 보관한다. 네트워크 파티션이 없는 환경에서는 n1에 기록된 데이터는 자동으로 n2와 n3에 복제된다. → 일관성과 가용성 모두 만족

네트워크 파티션이 발생하여 n3에 장애 발생
→ n1,n2에 기록된 데이터는 n3에 전달되지 않는다.
→ n3에 기록되었지만 아직 n1,n2에 전달되지 않은 데이터가 있다면 n1과 n2에는 오래된 사본을 갖는다.

이제 C 와 A 중 무엇을 포기할것인지 선택해야한다.

### C(일관성)는 못버려~~

데이터 불일치 문제를 막아야한다. n1과 n2에 쓰기 연산을 막아야 n3(장애)와 동일한 데이터를 갖게 된다. 그러면 가용성이 깨진다. 은행권이 여기에 해당. 온라인 뱅킹 시스템이 계좌 최신 정보를 출력하지 못한다면 큰 문제, 해결될때까지는 오류를 반환해야한다.

### A(가용성)은 못버려~~

낡은 데이터를 반환하더라도 시스템은 계속 읽기 연산을 허용해서 가용성을 높여야한다. 또한 장애가 없는 n1,n2는 쓰기 연산 또한 허용할 것이고 장애가 해결되면 새 데이터를 n3에 전송한다. 예로는 aws dynamo와 cassandra가 있습니다.

## 데이터 파티션

모든 데이터를 한 서버에 못 넣는다면 데이터를 작은 파티션으로 나누어서 여러대에 분산 저장한다. 이때 두가지 문제가 대두

- 데이터를 여러 서버에 고르게 분산 가능?
- 노드의 추가와 삭제 때마다 데이터의 이동을 최소화 할 수 있는가?

### 안정 해시를 사용하자

1. 서버(및 가상노드들)를 해시 링에 먼저 배치
2. 키를 링에 배치
3. 해당 키의 시계방향 순회시 첫번째로 만나는 노드에 저장한다.

좋은점

1. 규모 확장 자동화
2. 다양성 : 우수한 성능의 서버는 가상 노드를 많이 배치하여 파티션의 수를 크게 한다.

## 데이터 다중화

N개의 서버에 데이터를 비동기적으로 다중화 하여야한다.

해당 키의 시계방향 순회시 만나는 n개의 노드에 사본을 저장한다.

### 주의점

- n개의 가상노드를 선택한다. → n개의 서버가 아님. 즉 실제 물리서버는 n개보다 작을수도
- 선택된 가상노드들은 모두 다른 물리서버를 가르켜야 함. 같은 서버에 데이터 사본을 두면 장애 발생시 무력화될 가능성 높다.

## 데이터 일관성

정족수 합의(Quorum Consensus) 프로토콜을 활용하여 읽기/쓰기 연산 모두에 일관성을 보장

N = 사본 개수, W = 쓰기 연산 정족수, R = 읽기 연산 정족수

각 연산이 성공한 것으로 간주되려면 적어도 W개, R개 서버로부터 응답을 받아야한다.

### 중재자는 클라이언트와 노드 사이에서 성공 응답들을 받는다.

W=1이라면 하나의 노드로부터 쓰기 성공 응답을 받는다면 다른 노드들의 응답을 더이상 기다릴 필요가 없다.

따라서 W, R이 1이라면 응답 속도는 빠를것이다. 이것이 커지면 응답 속도는 가장 느린 서버의 응답 속도와 동일

### W+R > N 이면 강한 일관성을 보장. 적어도 한개의 노드는 W에 대해서도 R에 대해서도 최신 데이터임을 보장하기 때문이다.

- R=1, W=N → 빠른 읽기 연산에 최적화된 시스템
- R=N, W=1 → 빠른 쓰기 연산에 최적화된 시스템
- W+R > N   → 강한 일관성 보장 (보통 N=3,W=R=2)
- W+R ≤ N   → 강한 일관성 보장 X

### 강한 일관성

모든 읽기 연산은 가장 최근에 갱신된 결과를 반환한다. 절대로 낡은 데이터를 보지 못한다.

### 약한 일관성

그렇지 않을수도 있다.

### 최종 일관성

결국에는 갱신 결과가 모든 사본에 반영된다.

이를 따를 경우 쓰기 연산이 병렬적으로 발생하면 시스템에 저장된 값의 일관성이 깨질 수 있는데, 이 문제는 클라이언트가 해결해야한다.

### 비 일관성 해소 기법 : 데이터 버저닝, 벡터 시계

데이터를 변경할 때마다 해당 데이터의 새로운 버전을 만든다.

벡터 시계 = [서버, 버전] = [S_i,V_i]

한 벡터 시계의 구성요소들이 다른 한 벡터 시계의 구성요소보다 모두 크거나 같다면 포함관계가 성립되며, 충돌이 없음을 의미한다.

반면 그렇지 않다면 충돌을 의미하고 이를 클라이언트에서 해결한다.

### 문제점

- 해결 로직이 클라이언트에 들어가야 하므로 클라이언트 구현이 복잡해진다.
- 벡터 시계의 길이가 빨리 길어진다. 이를 해결하기 위해 임계치에 도달하면 오래된 순서쌍을 제거하는데, 때문에 버전 간 선후 관계가 정확하게 결정될 수 없어 해소 과정의 효율성이 낮아진다. 다만 Dynamo측은 이것 때문에 문제 생긴적 없다고 말했고 따라서 대부분의 기업에게는 사용해도 될것이다.
