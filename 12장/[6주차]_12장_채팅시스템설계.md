국내에는 카카오톡이 대표적인 채팅 어플로 쓰이지만, 다양한 채팅 어플들이 있으며 각 채팅 어플이 집중하는 영역도 다르다. (디스코드, 라인 등)
만약에 채팅을 설계해야 하는 상황이라면, 서비스의 특징과 채팅의 목적에 따라 설계하는 방향도 달라져야 한다.

# 1단계 : 문제 이해 및 설계 범위 확정

- 1:1 채팅 or 그룹 채팅
- 모바일 앱 vs 웹 앱
- 트래픽의 규모
- 그룹 채팅의 인원 규모
- 파일 첨부 여부
- 1회 채팅시 최대 텍스트 길이
- 보안 (암호화)
- 채팅 이력 저장 및 조회

<hr>
# 2단계 개략적 설계안 제시 및 동의 구하기
채팅 시스템은 P2P와 유사하게 동작하지만, 클라이언트끼리 직접 통신을 하지 않고, 서버가 중계를 하는 방식이다.
**즉 채팅서버에서는 아래의 기능들을 제공해야한다.**

- 클라이언트로부터 메시지 수신
- 메시지 수신자 결정 및 전달
- 수신자의 접속 여부에 따른 메시지 전달 여부 결정(저장)
  `<img width="457" alt="Pasted image 20240303153620" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/9ee1e58c-5b7c-48c7-9ab9-215dccc2071a">`

실시간 채팅을 구현하기 위해서 다양한 프로토콜을 선택할 수도 있다. 현존하는 가장 신뢰성 있고, 자주 사용되는 **HTTP**프로토콜을 사용하지만, 메시지의 수신자 입장에서 메시지를 관리하기가 HTTP의 특징상 힘들기 때문에 다양한 기법들을 사용하여 실시간 채팅을 구현했다.

## 폴링

주기적으로 수신자의 상태를 계속 체크하는 방식
`<img width="480" alt="Pasted image 20240303154042" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/85b9c7b4-a95c-4d08-a14e-0ae72cbea607">`

## 롱폴링

폴링 방식의 비효율성을 개선시킨 방법. 새 메시지가 반환 될 때까지는 연결을 유지한다.
`<img width="416" alt="Pasted image 20240303154139" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/f497ffdd-8975-4a43-8479-1f11cd01cb8b">`

- 가장 치명적인 약점은 서버 입장에선 클라이언트가 연결을 해제했는지 알 수 있는 방법이 없다.

## 웹소켓

현재 가장 대중적으로 채팅어플을 설계할때 사용하는 프로토콜.
HTTP 핸드셰이크를 진행하지만, 웹소켓 연결로 업그레이드 되는 방식이다.
`<img width="453" alt="Pasted image 20240303154447" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/015e8052-4113-4f58-9f3a-a2d3194c5d87">`

- 80, 443포트를 사용하기 때문에 방화벽에 걸리지 않음
- 양방향 메시지 전송 제공

## 개략적 설계 (웹 소켓 사용)

대부분의 기능은 일반적인 HTTP를 사용하여 설계를 해도 된다.
우리가 설계해볼 채팅 시스템은 크게 3부분으로 나눌 수 있다.

- 무상태 서비스
- 상태유지 서비스
- 제3자 서비스 연동
  `<img width="436" alt="Pasted image 20240303155023" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/dd7e4d2e-0d6d-416a-acaa-4216fc31059f">`

이와 같이 하나의 서버로 모든일이 처리가 가능하겠지만, 설계 면접에서는 항상 서버의 확장성을 고려해야 한다.
'이것은 그저 시작일 뿐'이라는 인식을 심자.
`<img width="479" alt="Pasted image 20240303155210" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/0742a39d-a1db-4403-8f82-c5a9a7f68eb2">`

- 채팅 서버는 클라이언트 사이 메시지 중계한다.
- 접속상태 서버는 사용자의 접속 여부를 관리한다.
- API서버는 로그인, 회원 가입 등 채팅을 제외한 나머지를 처리한다.
- 알림 서버는 푸시 알림을 보낸다.
- 키-값 저장소는 채팅내역을 저장한다.

## 저장소

개인적으로 채팅시스템의 꽃이라고 생각한다. 모든 서비스가 준비되었을 때 사용자의 채팅내역을 어디에, 어떻게, 얼마나 저장할 것인지를 정해야한다.
채팅 시스템에서는 2가지의 데이터를 다룬다.

1. 사용자 프로파일, 설정, 친구 목록 (보편적으로 관계형 데이터 베이스)
2. 채팅 이력 (이건 어디에 저장을 해야할까?)

### **<채팅 이력을 어디에 저장할 것인가?>**

- 채팅 이력의 양은 엄청나다.
- 오래된 메시지는 잘 보지 않음
- 하지만 메시지를 검색하여 특정 메시지를 조회하는 등 무작위적인 데이터 접근도 일어난다.
- 1:1 채팅은 읽기, 쓰기 비율이 1:1이다.

=> 본 책에서는 키-값 데이터베이스를 추천한다.

### **<키-값 데이터 베이스>**

- 수평적 규모 확장이 쉽다.
- 데이터 접근 지연시간이 낮다.
- 관계형 데이터베이스는 인덱스가 커지면 무작위 데이터 접근에 취약해진다.
- 이미 시중의 채팅 서비스는 키-값 DB를 사용한다.

## 메시지 저장

**<1:1 채팅>**
`<img width="176" alt="Pasted image 20240303160340" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/d9700d85-2697-4f03-bb0b-6619190dcc86">`

**<그룹 채팅>**
`<img width="178" alt="Pasted image 20240303160418" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/788b3143-e240-4bb5-bd7b-29a120b7cb6a">`

### 메시지 ID

- 메시지 ID의 값은 고유해야한다.
- ID값은 정렬가능해야 하며 시간순서와 일치해야 한다. 즉, 새로운ID는 이전 ID보다 큰 값이어야 한다.

이를 위한 방법은 3가지 방법이 있다.

1. Auto_Increment (RDBMS 만 제공)
2. 스노우 플레이크
3. 지역적 순서 번호 생성기 (채팅방 내에서만 고유하면 되므로 채택이 가능하다.)

<hr>
# 3단계 : 상세 설계
상세 설계에서는 개략적 설계에서 **서비스 탐색, 메시지 전달 흐름, 사용자 접속 상태 표시** 정도만 상세하게 설명할 일이 생길 것이다.

## 서비스 탐색

클라이언트에게 가장 적합한 채팅서버를 추천하는 서비스이다. 이때 사용되는 기준으로는 **클라이언트의 위치, 서버의 용량** 등이 있다.
가장 자주 사용되는 **아파치 주키퍼**를 예시로 이 책에서는 설명하고 있다.
`<img width="423" alt="Pasted image 20240303161125" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/0a164776-9c56-4ecd-87b6-5bbe02e2fc8b">`

1. 사용자 A가 시스템에 로그인을 시도한다.
2. 로드벨런서가 로그인 요청을 API서버에 .
3. API서버가 사용자인증을 처리하면 서비스 탐색기능이 동작하여 적절한 채팅서버로 보낸다.
4. 사용자 A는 채팅서버 2와 웹소켓 연결을 맺는다.

## 메시지 흐름

메시지 흐름에는 크게 2가지인 1:1, 1:N 의 경우가 있다.

### 1:1 메시지 처리 흐름

<img width="422" alt="Pasted image 20240303161557" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/0d24ded0-6b87-4588-9d89-5c8a2b9604c4">

1. 사용자A가 채팅서버1로 메시지 전송
2. 채팅서버1은 ID생성기를 사용 해당메시지의 ID결정
3. 채팅서버1은 해당 메시지를 메시지 동기화 큐로 전송
4. 메시지가 키-값 저장소에 보관됨
5. (a)사용자B가 접속중인 경우 메시지는 사용자B가 접속중인 채팅 서버로 전송됨
6. (b)사용자B가 접속 중이 아니라면 푸시 알림 메시지를 푸시 알림 서버로 보냄
7. 채팅서버2는 메시지를 사용자B에게 전송. 사용자B 와 채팅서버2 사이에는 웹소켓연결이 있는 상태이므로 그것을 이용

### 여러 단말 사이의 메시지 동기화

<img width="457" alt="Pasted image 20240303161901" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/613b27f4-f524-4c86-8fe4-d06073d58f9c">

아래 조건에 만족하는 메시지는 새 메시지로 간주한다.

- 수신자 ID가 현재 로그인한 사용자 ID와 같다.
- 키-값 저장소에 보관된 메시지로서, 그 ID가 cur_max_message_id보다 크다.

### 소규모 그룹 채팅에서의 메시지 흐름

<img width="362" alt="Pasted image 20240303162100" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/21ecad79-e592-4e1a-b3aa-4f553cb18630">

이렇게 소규모 채팅의 경우에 메시지 동기화 큐를 쓰는 것이 유리하다. 이유는 다음과 같다.

- 새로운 메시지를 확인하려면 자신의 큐만 보면 되기 때문에 메시지 동기화가 간편하다.
- 그룹이 크지 않으면 동일한 메시지를 복사하는 것은 크게 문제가 되지 않는다.

## 접속 상태 표시

개략적 설계안에서는 접속 상태 서버를 통해 사용자의 상태를 관리하는데, 사용자의 상태가 바뀌는 시나리오에는 크게 3가지가 있다.

1. 사용자 로그인
2. 로그아웃
3. 접속 장애

이를 어떻게 표시해야 할지 한번 알아보자.

### 사용자 로그인

클라이언트와 실시간 서비스 사이에 웹소켓 연결이 맺어지고 나면 접속 상태 서버는 A의 상태와 last_active_at 타임스탬프 값을 키-값 저장소에 저장한다.

<img width="434" alt="Pasted image 20240303162644" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/e30cd316-d223-4cf2-bfa6-2b4052838e7a">

### 로그아웃

<img width="486" alt="Pasted image 20240303162709" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/cddcb75e-a13e-4d37-9c01-292ab561abca">

### 접속 장애

인터넷 연결이 불안정 하다면, 웹소켓에 접속중인 모든 유저가 연결이 끊어지게 된다.
그래서 가장 간단한 방법은 연결이 끊어지면 사용자의 상태를 바로 **오프라인으로** 변경하고 연결이 복구되면 바로 **온라인으로** 변경해주는 방식이 있다.

하지만, 짧은시간동안만 연결이 끊어지는 경우가 굉장히 많은데, 이럴때마다 모든 사용자의 상태를 변경해버리면, 이에 따른 오버헤드도 커진다

그래서 이를 해결 하기 위해 **박동 검사**를 통해 사용자의 상태를 관리한다.

<img width="461" alt="Pasted image 20240303163019" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/e6f9b658-a628-44b0-bcc4-5338cf3ed52f">

**상태 정보의 전송**
그러면 다른 사용자의 상태정보는 어떻게 전달이 될까?
이는 구독 발행 패턴을 사용해 사용자끼리 서로 구독 발행을 하는 방식으로 해결한다.

<img width="426" alt="Pasted image 20240303163144" src="https://github.com/SSAFY-Seoul-20-Study/book-system-design-interview/assets/53340295/5fce728b-c8ad-4ad1-a85a-f71f229e237a">

하지만 이는 그룹의 크기가 커지면 오버헤드가 크게 발생한다.

# 4단계 : 마무리

우리는 지금까지 웹소켓을 활용하여 **채팅서버, 접속 상태 서버, 푸시알림 서버, 채팅 내역 저장소, API서버** 등을 구현하였다.
더 추가적으로 아래와 같은 내용들을 구현해보고 이야기 해 볼 수 있다.

- 채팅앱에서 비디오, 이미지등을 제공하기 위해 압축 방식, 클라우드 저장소, 썸네일 생성
- 메시지 암호화
- 캐시
- 로딩 속도 개선
- 오류 처리 (메시지 전송 실패, 재전송 등)
